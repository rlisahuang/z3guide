"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[392],{7224:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>p,toc:()=>m});var i=t(3117),a=(t(7294),t(3905)),o=t(7634),s=t.n(o);const r={title:"Introduction",sidebar_position:1},l="Z3 API in Python",p={unversionedId:"Z3 Python - Readonly/Introduction",id:"Z3 Python - Readonly/Introduction",title:"Introduction",description:"This tutorial demonstrates the main capabilities of Z3Py: the Z3 API in Python. There are many benefits to using, Z3Py. First, it is much more familiar to individuals who have seen programming languages before, but have never seen functional languages like Z3.",source:"@site/docs-programming/02 - Z3 Python - Readonly/01 - Introduction.md",sourceDirName:"02 - Z3 Python - Readonly",slug:"/Z3 Python - Readonly/Introduction",permalink:"/z3guide/programming/Z3 Python - Readonly/Introduction",draft:!1,editUrl:"https://github.com/rlisahuang/z3guide/tree/main/website/docs-programming/02 - Z3 Python - Readonly/01 - Introduction.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Introduction",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Z3 JavaScript",permalink:"/z3guide/programming/Z3 JavaScript Examples"},next:{title:"Advanced Topics",permalink:"/z3guide/programming/Z3 Python - Readonly/advanced"}},d={},m=[{value:"Using Z3Py Locally",id:"using-z3py-locally",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Boolean Logic",id:"boolean-logic",level:2},{value:"Solvers",id:"solvers",level:2},{value:"Arithmetic",id:"arithmetic",level:2},{value:"Machine Arithmetic",id:"machine-arithmetic",level:2},{value:"Functions",id:"functions",level:2},{value:"Satisfiability and Validity",id:"satisfiability-and-validity",level:2},{value:"List Comprehensions",id:"list-comprehensions",level:2},{value:"Kinematic Equations",id:"kinematic-equations",level:2},{value:"Problem 1",id:"problem-1",level:3},{value:"Problem 2",id:"problem-2",level:3},{value:"Bit Tricks",id:"bit-tricks",level:2},{value:"Power of two",id:"power-of-two",level:3},{value:"Opposite signs",id:"opposite-signs",level:3},{value:"Puzzles",id:"puzzles",level:2},{value:"Dog, Cat and Mouse",id:"dog-cat-and-mouse",level:3},{value:"Sudoku",id:"sudoku",level:3},{value:"Eight Queens",id:"eight-queens",level:3},{value:"Application: Install Problem",id:"application-install-problem",level:2}],h={toc:m};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"z3-api-in-python"},"Z3 API in Python"),(0,a.kt)("p",null,"This tutorial demonstrates the main capabilities of Z3Py: the Z3 API in ",(0,a.kt)("a",{parentName:"p",href:"http://www.python.org"},"Python"),". There are many benefits to using, Z3Py. First, it is much more familiar to individuals who have seen programming languages before, but have never seen functional languages like Z3.",(0,a.kt)("br",{parentName:"p"}),"\n","No Python background is needed to read and following along with this tutorial. However, it is useful to learn Python (a fun language!) at some point for other purposes. There are many excellent free resources for doing so ",(0,a.kt)("a",{parentName:"p",href:"http://docs.python.org/tutorial/"},"Python Tutorial"),"."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The Z3 distribution also contains the ",(0,a.kt)("strong",{parentName:"p"},"C"),", ",(0,a.kt)("strong",{parentName:"p"},"C++"),", ",(0,a.kt)("strong",{parentName:"p"},".Net"),", ",(0,a.kt)("strong",{parentName:"p"},"Java"),", ",(0,a.kt)("strong",{parentName:"p"},"Julia"),", ",(0,a.kt)("strong",{parentName:"p"},"JS")," and ",(0,a.kt)("strong",{parentName:"p"},"OCaml")," APIs.\nThe source code of Z3Py is available in the Z3 distribution, feel free to modify it to meet your needs. ")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{parentName:"p",href:"https://z3prover.github.io/papers/programmingz3.html"},"The following guide on ",(0,a.kt)("em",{parentName:"a"},"Programming Z3")," is available as a reference"))),(0,a.kt)("p",null,"In the present form this tutorial is static. You can run the examples locally by copying the text into a python interpreter where you have imported z3."),(0,a.kt)("h3",{id:"using-z3py-locally"},"Using Z3Py Locally"),(0,a.kt)("p",null,"The Python bindings are available from pypi. You can install them using the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    pip install z3-solver\n")),(0,a.kt)("h2",{id:"getting-started"},"Getting Started"),(0,a.kt)("p",null,"Let us start with the following simple example:"),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Int('x')\ny = Int('y')\nsolve(x > 2, y < 10, x + 2*y == 7)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The function ",(0,a.kt)("inlineCode",{parentName:"p"},"Int('x')")," creates an integer variable in Z3 named ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),".\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"solve")," function solves a system of constraints. The example above uses\ntwo variables ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),", and three constraints:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"x must be greater than 2\ny must be less than 10\nwhen x is added to twice the value of y, it must equal 7")),(0,a.kt)("p",null,"Z3Py like Python uses ",(0,a.kt)("inlineCode",{parentName:"p"},"=")," for assignment. The operators ",(0,a.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,a.kt)("inlineCode",{parentName:"p"},">"),", ",(0,a.kt)("inlineCode",{parentName:"p"},">="),", ",(0,a.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," for comparison.\nIn the example above, the expression ",(0,a.kt)("inlineCode",{parentName:"p"},"x + 2*y  == 7")," is a Z3 constraint.\nZ3 can solve and crunch formulas."),(0,a.kt)("p",null,"The next examples show how to use the Z3 formula/expression simplifier."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Int('x')\ny = Int('y')\nprint (simplify(x + y + 2*x + 3))\nprint (simplify(x < y + x + 2))\nprint (simplify(And(x + 1 >= 3, x**2 + x**2 + y**2 + 2 >= 5)))",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"By default, Z3Py (for the web) displays formulas and expressions using mathematical notation.\nAs usual, ",(0,a.kt)("span",{parentName:"p",className:"math math-inline"},(0,a.kt)("span",{parentName:"span",className:"katex"},(0,a.kt)("span",{parentName:"span",className:"katex-mathml"},(0,a.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.kt)("semantics",{parentName:"math"},(0,a.kt)("mrow",{parentName:"semantics"},(0,a.kt)("mo",{parentName:"mrow"},"\u2227")),(0,a.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\wedge")))),(0,a.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5556em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"\u2227")))))," is the logical and, ",(0,a.kt)("span",{parentName:"p",className:"math math-inline"},(0,a.kt)("span",{parentName:"span",className:"katex"},(0,a.kt)("span",{parentName:"span",className:"katex-mathml"},(0,a.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.kt)("semantics",{parentName:"math"},(0,a.kt)("mrow",{parentName:"semantics"},(0,a.kt)("mo",{parentName:"mrow"},"\u2228")),(0,a.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\vee")))),(0,a.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5556em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"\u2228")))))," is the logical or, and so on.\nThe command ",(0,a.kt)("inlineCode",{parentName:"p"},"set_option(html_mode=False)")," makes all formulas and expressions to be\ndisplayed in Z3Py notation. This is also the default mode for the offline version of Z3Py that\ncomes with the Z3 distribution."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Int('x')\ny = Int('y')\nprint (x**2 + y**2 >= 1)\nset_option(html_mode=False)\nprint (x**2 + y**2 >= 1)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"Z3 provides functions for traversing expressions."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'x = Int(\'x\')\ny = Int(\'y\')\nn = x + y >= 3\nprint ("num args: ", n.num_args())\nprint ("children: ", n.children())\nprint ("1st child:", n.arg(0))\nprint ("2nd child:", n.arg(1))\nprint ("operator: ", n.decl())\nprint ("op name:  ", n.decl().name())',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"Z3 provides all basic mathematical operations. Z3Py uses the same operator precedence of the Python language.\nLike Python, ",(0,a.kt)("inlineCode",{parentName:"p"},"**")," is the power operator. Z3 can solve nonlinear ",(0,a.kt)("em",{parentName:"p"},"polynomial")," constraints."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Real('x')\ny = Real('y')\nsolve(x**2 + y**2 > 3, x**3 + y < 5)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The procedure ",(0,a.kt)("inlineCode",{parentName:"p"},"Real('x')")," creates the real variable ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),".\nZ3Py can represent arbitrarily large integers, rational numbers (like in the example above),\nand irrational algebraic numbers. An irrational algebraic number is a root of a polynomial with integer coefficients.\nInternally, Z3 represents all these numbers precisely.\nIrrational numbers are displayed in decimal notation for making it easy to read the results."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Real('x')\ny = Real('y')\nsolve(x**2 + y**2 == 3, x**3 == 2)\n\nset_option(precision=30)\nprint \"Solving, and displaying result with 30 decimal places\"\nsolve(x**2 + y**2 == 3, x**3 == 2)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The procedure ",(0,a.kt)("inlineCode",{parentName:"p"},"set_option")," is used to configure the Z3 environment. It is used to set global configuration options\nsuch as how the result is displayed. The option ",(0,a.kt)("inlineCode",{parentName:"p"},"set_option(precision=30)")," sets the number of decimal places used when displaying results.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"?")," mark in ",(0,a.kt)("inlineCode",{parentName:"p"},"1.2599210498?")," indicates the output is truncated."),(0,a.kt)("p",null,"The following example demonstrates a common mistake. The expression ",(0,a.kt)("inlineCode",{parentName:"p"},"3/2")," is a Python integer and not a Z3 rational number.\nThe example also shows different ways to create rational numbers in Z3Py. The procedure ",(0,a.kt)("inlineCode",{parentName:"p"},"Q(num, den)")," creates a\nZ3 rational where ",(0,a.kt)("inlineCode",{parentName:"p"},"num")," is the numerator and ",(0,a.kt)("inlineCode",{parentName:"p"},"den")," is the denominator. The ",(0,a.kt)("inlineCode",{parentName:"p"},"RealVal(1)")," creates a Z3 real number\nrepresenting the number ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"print 1/3\nprint RealVal(1)/3\nprint Q(1,3)\n\nx = Real('x')\nprint (x + 1/3)\nprint (x + Q(1,3))\nprint (x + \"1/3\")\nprint (x + 0.25)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"Rational numbers can also be displayed in decimal notation."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Real('x')\nsolve(3*x == 1)\n\nset_option(rational_to_decimal=True)\nsolve(3*x == 1)\n\nset_option(precision=30)\nsolve(3*x == 1)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"A system of constraints may not have a solution. In this case, we say the system is ",(0,a.kt)("strong",{parentName:"p"},"unsatisfiable"),"."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Real('x')\nsolve(x > 4, x < 0)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"Like in Python, comments begin with the hash character ",(0,a.kt)("inlineCode",{parentName:"p"},"#")," and are terminated by the end of line.\nZ3Py does not support comments that span more than one line."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"# This is a comment\nx = Real('x') # comment: creating x\nprint (x**2 + 2*x + 2)  # comment: printing polynomial",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"boolean-logic"},"Boolean Logic"),(0,a.kt)("p",null,"Z3 supports Boolean operators: ",(0,a.kt)("inlineCode",{parentName:"p"},"And"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Or"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Not"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Implies")," (implication),\n",(0,a.kt)("inlineCode",{parentName:"p"},"If")," (if-then-else). Bi-implications are represented using equality ",(0,a.kt)("inlineCode",{parentName:"p"},"=="),".\nThe following example shows how to solve a simple set of Boolean constraints."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"p = Bool('p')\nq = Bool('q')\nr = Bool('r')\nsolve(Implies(p, q), r == Not(q), Or(Not(p), r))      ",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The Python Boolean constants ",(0,a.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"False")," can be used to build Z3 Boolean expressions."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"p = Bool('p')\nq = Bool('q')\nprint (And(p, q, True))\nprint (simplify(And(p, q, True)))\nprint (simplify(And(p, False)))",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The following example uses a combination of polynomial and Boolean constraints. "),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"p = Bool('p')\nx = Real('x')\nsolve(Or(x < 5, x > 10), Or(p, x**2 == 2), Not(p))",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"solvers"},"Solvers"),(0,a.kt)("p",null,"Z3 provides different solvers. The command ",(0,a.kt)("inlineCode",{parentName:"p"},"solve"),", used in the previous examples, is implemented using the Z3 solver API.\nThe implementation can be found in the file ",(0,a.kt)("inlineCode",{parentName:"p"},"z3.py")," in the Z3 distribution.\nThe following example demonstrates the basic Solver API."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'x = Int(\'x\')\ny = Int(\'y\')\n\ns = Solver()\nprint s\n\ns.add(x > 10, y == x + 2)\nprint (s)\nprint ("Solving constraints in the solver s ...")\nprint (s.check())\n\nprint ("Create a new scope...")\ns.push()\ns.add(y < 11)\nprint (s)\nprint ("Solving updated set of constraints...")\nprint (s.check())\n\nprint ("Restoring state...")\ns.pop()\nprint (s)\nprint ("Solving restored set of constraints...")\nprint (s.check())',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The command ",(0,a.kt)("inlineCode",{parentName:"p"},"Solver()")," creates a general purpose solver. Constraints can be added using the method ",(0,a.kt)("inlineCode",{parentName:"p"},"add"),".\nWe say the constraints have been ",(0,a.kt)("strong",{parentName:"p"},"asserted")," in the solver. The method ",(0,a.kt)("inlineCode",{parentName:"p"},"check()")," solves the asserted constraints.\nThe result is ",(0,a.kt)("inlineCode",{parentName:"p"},"sat")," (satisfiable) if a solution was found. The result is ",(0,a.kt)("inlineCode",{parentName:"p"},"unsat")," (unsatisfiable) if\nno solution exists. We may also say the system of asserted constraints is ",(0,a.kt)("strong",{parentName:"p"},"infeasible"),". Finally, a solver may fail\nto solve a system of constraints and ",(0,a.kt)("inlineCode",{parentName:"p"},"unknown")," is returned.   "),(0,a.kt)("p",null,"In some applications, we want to explore several similar problems that share several constraints.\nWe can use the commands ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"pop")," for doing that.\nEach solver maintains a stack of assertions. The command ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," creates a new scope by\nsaving the current stack size.\nThe command ",(0,a.kt)("inlineCode",{parentName:"p"},"pop")," removes any assertion performed between it and the matching ",(0,a.kt)("inlineCode",{parentName:"p"},"push"),".\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"check")," method always operates on the content of solver assertion stack."),(0,a.kt)("p",null,"The following example shows an example that Z3 cannot solve. The solver returns ",(0,a.kt)("inlineCode",{parentName:"p"},"unknown")," in this case.\nRecall that Z3 can solve nonlinear polynomial constraints, but ",(0,a.kt)("inlineCode",{parentName:"p"},"2**x")," is not a polynomial."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Real('x')\ns = Solver()\ns.add(2**x == 3)\nprint (s.check())",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The following example shows how to traverse the constraints asserted into a solver, and how to collect performance statistics for\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"check")," method."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'x = Real(\'x\')\ny = Real(\'y\')\ns = Solver()\ns.add(x > 1, y > 1, Or(x + y > 3, x - y < 2))\nprint("asserted constraints...")\nfor c in s.assertions():\n    print(c)\n\nprint(s.check())\nprint("statistics for the last check method...")\nprint(s.statistics())\n# Traversing statistics\nfor k, v in s.statistics():\n    print (k, " : ", v)',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The command ",(0,a.kt)("inlineCode",{parentName:"p"},"check")," returns ",(0,a.kt)("inlineCode",{parentName:"p"},"sat")," when Z3 finds a solution for the set of asserted constraints.\nWe say Z3 ",(0,a.kt)("strong",{parentName:"p"},"satisfied")," the set of constraints. We say the solution is a ",(0,a.kt)("strong",{parentName:"p"},"model")," for the set of asserted\nconstraints. A model is an ",(0,a.kt)("strong",{parentName:"p"},"interpretation")," that makes each asserted constraint ",(0,a.kt)("strong",{parentName:"p"},"true"),".\nThe following example shows the basic methods for inspecting models. "),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'x, y, z = Reals(\'x y z\')\ns = Solver()\ns.add(x > 1, y > 1, x + y > 3, z - x < 10)\nprint (s.check())\n\nm = s.model()\nprint ("x = %s" % m[x])\n\nprint "traversing model..."\nfor d in m.decls():\n    print ("%s = %s" % (d.name(), m[d]))\n',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"In the example above, the function ",(0,a.kt)("inlineCode",{parentName:"p"},"Reals('x y z')")," creates the variables. ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"z"),".\nIt is shorthand for:"),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Real('x')\ny = Real('y')\nz = Real('z')",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The expression ",(0,a.kt)("inlineCode",{parentName:"p"},"m[x]")," returns the interpretation of ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," in the model ",(0,a.kt)("inlineCode",{parentName:"p"},"m"),".\nThe expression ",(0,a.kt)("inlineCode",{parentName:"p"},'"%s = %s" % (d.name(), m[d])')," returns a string where the first ",(0,a.kt)("inlineCode",{parentName:"p"},"%s")," is replaced with\nthe name of ",(0,a.kt)("inlineCode",{parentName:"p"},"d")," (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"d.name()"),"), and the second ",(0,a.kt)("inlineCode",{parentName:"p"},"%s")," with a textual representation of the\ninterpretation of ",(0,a.kt)("inlineCode",{parentName:"p"},"d")," (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"m[d]"),"). Z3Py automatically converts Z3 objects into a textual representation\nwhen needed."),(0,a.kt)("h2",{id:"arithmetic"},"Arithmetic"),(0,a.kt)("p",null,"Z3 supports real and integer variables. They can be mixed in a single problem.\nLike most programming languages, Z3Py will automatically add coercions converting integer expressions to real ones when needed.\nThe following example demonstrates different ways to declare integer and real variables."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Real('x')\ny = Int('y')\na, b, c = Reals('a b c')\ns, r = Ints('s r')\nprint (x + y + 1 + (a + s))\nprint (ToReal(y) + c)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The function ",(0,a.kt)("inlineCode",{parentName:"p"},"ToReal")," casts an integer expression into a real expression."),(0,a.kt)("p",null,"Z3Py supports all basic arithmetic operations."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"a, b, c = Ints('a b c')\nd, e = Reals('d e')\nsolve(a > b + 2,\n      a == 2*c + 10,\n      c + b <= 1000,\n      d >= e)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The command ",(0,a.kt)("inlineCode",{parentName:"p"},"simplify")," applies simple transformations on Z3 expressions."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x, y = Reals('x y')\n# Put expression in sum-of-monomials form\nt = simplify((x + y)**3, som=True)\nprint t\n# Use power operator\nt = simplify(t, mul_to_power=True)\nprint t",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The command ",(0,a.kt)("inlineCode",{parentName:"p"},"help_simplify()")," prints all available options.\nZ3Py allows users to write option in two styles. The Z3 internal option names start with ",(0,a.kt)("inlineCode",{parentName:"p"},":")," and words are separated by ",(0,a.kt)("inlineCode",{parentName:"p"},"-"),".\nThese options can be used in Z3Py. Z3Py also supports Python-like names,\nwhere ",(0,a.kt)("inlineCode",{parentName:"p"},":")," is suppressed and ",(0,a.kt)("inlineCode",{parentName:"p"},"-")," is replaced with ",(0,a.kt)("inlineCode",{parentName:"p"},"_"),".\nThe following example demonstrates how to use both styles."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x, y = Reals('x y')\n# Using Z3 native option names\nprint (simplify(x == y + 2, ':arith-lhs', True))\n# Using Z3Py option names\nprint (simplify(x == y + 2, arith_lhs=True))\n\nprint (\"\\nAll available options:\")\nhelp_simplify()",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"Z3Py supports arbitrarily large numbers. The following example demonstrates how to perform basic arithmetic using larger integer, rational and irrational numbers.\nZ3Py only supports ",(0,a.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Algebraic_number"},"algebraic irrational numbers"),". Algebraic irrational numbers are sufficient for presenting the solutions of systems of polynomial constraints.\nZ3Py will always display irrational numbers in decimal notation since it  is more convenient to read. The internal representation can be extracted using the method ",(0,a.kt)("inlineCode",{parentName:"p"},"sexpr()"),".\nIt displays Z3 internal representation for mathematical formulas and expressions in ",(0,a.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/S-expression"},"s-expression")," (Lisp-like) notation."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x, y = Reals('x y')\nsolve(x + 10000000000000000000000 == y, y > 20000000000000000)\n\nprint (Sqrt(2) + Sqrt(3))\nprint (simplify(Sqrt(2) + Sqrt(3)))\nprint (simplify(Sqrt(2) + Sqrt(3)).sexpr())\n# The sexpr() method is available for any Z3 expression\nprint ((x + Sqrt(y) * 2).sexpr())",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"machine-arithmetic"},"Machine Arithmetic"),(0,a.kt)("p",null,"Modern CPUs and main-stream programming languages use\narithmetic over fixed-size bit-vectors.\nMachine arithmetic is available in Z3Py as ",(0,a.kt)("i",null,"Bit-Vectors"),".\nThey implement the\nprecise semantics of unsigned and of\nsigned ",(0,a.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Two's_complement"},"two-complements arithmetic"),". "),(0,a.kt)("p",null,"The following example demonstrates how to create bit-vector variables and constants.\nThe function ",(0,a.kt)("inlineCode",{parentName:"p"},"BitVec('x', 16)")," creates a bit-vector variable in Z3 named ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," with ",(0,a.kt)("inlineCode",{parentName:"p"},"16")," bits.\nFor convenience, integer constants can be used to create bit-vector expressions in Z3Py.\nThe function ",(0,a.kt)("inlineCode",{parentName:"p"},"BitVecVal(10, 32)")," creates a bit-vector of size ",(0,a.kt)("inlineCode",{parentName:"p"},"32")," containing the value ",(0,a.kt)("inlineCode",{parentName:"p"},"10"),"."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = BitVec('x', 16)\ny = BitVec('y', 16)\nprint (x + 2)\n# Internal representation\nprint ((x + 2).sexpr())\n\n# -1 is equal to 65535 for 16-bit integers \nprint (simplify(x + y - 1))\n\n# Creating bit-vector constants\na = BitVecVal(-1, 16)\nb = BitVecVal(65535, 16)\nprint (simplify(a == b))\n\na = BitVecVal(-1, 32)\nb = BitVecVal(65535, 32)\n# -1 is not equal to 65535 for 32-bit integers \nprint (simplify(a == b))",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"In contrast to programming languages, such as C, C++, C#, Java,\nthere is no distinction between signed and unsigned bit-vectors\nas numbers. Instead, Z3 provides special signed versions of arithmetical operations\nwhere it makes a difference whether the bit-vector is treated as signed or unsigned.\nIn Z3Py, the operators\n",(0,a.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,a.kt)("inlineCode",{parentName:"p"},">"),", ",(0,a.kt)("inlineCode",{parentName:"p"},">="),", ",(0,a.kt)("inlineCode",{parentName:"p"},"/"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"%")," and ",(0,a.kt)("inlineCode",{parentName:"p"},">>;")," correspond to the signed versions.\nThe corresponding unsigned operators are\n",(0,a.kt)("inlineCode",{parentName:"p"},"ULT"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ULE"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"UGT"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"UGE"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"UDiv"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"URem")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"LShR"),"."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"# Create to bit-vectors of size 32\nx, y = BitVecs('x y', 32)\n\nsolve(x + y == 2, x > 0, y > 0)\n\n# Bit-wise operators\n# & bit-wise and\n# | bit-wise or\n# ~ bit-wise not\nsolve(x & y == ~y)\n\nsolve(x < 0)\n\n# using unsigned version of < \nsolve(ULT(x, 0))",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The operator ",(0,a.kt)("inlineCode",{parentName:"p"},">>")," is the arithmetic shift right, and\n",(0,a.kt)("inlineCode",{parentName:"p"},"<<")," is the shift left. The logical shift right is the operator ",(0,a.kt)("inlineCode",{parentName:"p"},"LShR"),"."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"# Create to bit-vectors of size 32\nx, y = BitVecs('x y', 32)\n\nsolve(x >> 2 == 3)\n\nsolve(x << 2 == 3)\n\nsolve(x << 2 == 24)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("p",null,"Unlike programming languages, where functions have side-effects, can throw exceptions,\nor never return, functions in Z3 have no side-effects and are ",(0,a.kt)("strong",{parentName:"p"},"total"),".\nThat is, they are defined on all input values. This includes functions, such\nas division. Z3 is based on ",(0,a.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/First-order_logic"},"first-order logic"),"."),(0,a.kt)("p",null,"Given a constraints such as ",(0,a.kt)("inlineCode",{parentName:"p"},"x + y > 3"),", we have been saying that ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),"\nare variables. In many textbooks, ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," are called uninterpreted constants.\nThat is, they allow any interpretation that is consistent with the constraint ",(0,a.kt)("inlineCode",{parentName:"p"},"x + y > 3"),"."),(0,a.kt)("p",null,"More precisely, function and constant symbols in pure first-order logic are ",(0,a.kt)("i",null,"uninterpreted")," or ",(0,a.kt)("i",null,"free"),",\nwhich means that no a priori interpretation is attached.\nThis is in contrast to functions belonging to the signature of theories,\nsuch as arithmetic where the function ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," has a fixed standard interpretation\n(it adds two numbers). Uninterpreted functions and constants are maximally flexible;\nthey allow any interpretation that is consistent with the constraints over the function or constant."),(0,a.kt)("p",null,"To illustrate uninterpreted functions and constants let us the uninterpreted integer constants (aka variables)\n",(0,a.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),". Finally let ",(0,a.kt)("inlineCode",{parentName:"p"},"f")," be an uninterpreted function that takes one argument of type (aka sort) integer\nand results in an integer value.\nThe example illustrates how one can force an interpretation where ",(0,a.kt)("inlineCode",{parentName:"p"},"f"),"\napplied twice to ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," results in ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," again, but ",(0,a.kt)("inlineCode",{parentName:"p"},"f")," applied once to ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," is different from ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Int('x')\ny = Int('y')\nf = Function('f', IntSort(), IntSort())\nsolve(f(f(x)) == x, f(x) == y, x != y)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"The solution (interpretation) for ",(0,a.kt)("inlineCode",{parentName:"p"},"f")," should be read as ",(0,a.kt)("inlineCode",{parentName:"p"},"f(0)")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"f(1)")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"f(a)"),"\nis ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," for all ",(0,a.kt)("inlineCode",{parentName:"p"},"a")," different from ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,a.kt)("p",null,"In Z3, we can also evaluate expressions in the model for a system of constraints. The following example shows how to\nuse the ",(0,a.kt)("inlineCode",{parentName:"p"},"evaluate")," method."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x = Int('x')\ny = Int('y')\nf = Function('f', IntSort(), IntSort())\ns = Solver()\ns.add(f(f(x)) == x, f(x) == y, x != y)\nprint (s.check())\nm = s.model()\nprint (\"f(f(x)) =\", m.evaluate(f(f(x))))\nprint (\"f(x)    =\", m.evaluate(f(x)))",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"satisfiability-and-validity"},"Satisfiability and Validity"),(0,a.kt)("p",null,"A formula/constraint ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is ",(0,a.kt)("strong",{parentName:"p"},"valid")," if ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," always evaluates to true for any assignment of appropriate values to its\nuninterpreted symbols.\nA formula/constraint ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is ",(0,a.kt)("strong",{parentName:"p"},"satisfiable")," if there is some assignment of appropriate values\nto its uninterpreted  symbols under which ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," evaluates to true.\nValidity is about finding a proof of a statement; satisfiability is about finding a solution to a set of constraints.\nConsider a formula ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," containing ",(0,a.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"b"),".\nWe can ask whether ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is valid, that is whether it is always true for any combination of values for\n",(0,a.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"b"),". If ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is always\ntrue, then ",(0,a.kt)("inlineCode",{parentName:"p"},"Not(F)")," is always false, and then ",(0,a.kt)("inlineCode",{parentName:"p"},"Not(F)")," will not have any satisfying assignment (i.e., solution); that is,\n",(0,a.kt)("inlineCode",{parentName:"p"},"Not(F)")," is unsatisfiable. That is,\n",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is valid precisely when ",(0,a.kt)("inlineCode",{parentName:"p"},"Not(F)")," is not satisfiable (is unsatisfiable).\nAlternately,\n",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is satisfiable if and only if ",(0,a.kt)("inlineCode",{parentName:"p"},"Not(F)")," is not valid (is invalid).\nThe following example proves the deMorgan's law."),(0,a.kt)("p",null,"The following example redefines the Z3Py function ",(0,a.kt)("inlineCode",{parentName:"p"},"prove")," that receives a formula as a parameter.\nThis function creates a solver, adds/asserts the negation of the formula, and check if the negation is unsatisfiable.\nThe implementation of this function is a simpler version of the Z3Py command ",(0,a.kt)("inlineCode",{parentName:"p"},"prove"),"."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'p, q = Bools(\'p q\')\ndemorgan = And(p, q) == Not(Or(Not(p), Not(q)))\nprint (demorgan)\n\ndef prove(f):\n    s = Solver()\n    s.add(Not(f))\n    if s.check() == unsat:\n        print ("proved")\n    else:\n        print ("failed to prove")\n\nprint ("Proving demorgan...")\nprove(demorgan)',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"list-comprehensions"},"List Comprehensions"),(0,a.kt)("p",null,"Python supports ",(0,a.kt)("a",{parentName:"p",href:"http://docs.python.org/tutorial/datastructures.html#list-comprehensions"},"list comprehensions"),"\nList comprehensions provide a concise way to create lists. They can be used to create Z3 expressions and problems in Z3Py.\nThe following example demonstrates how to use Python list comprehensions in Z3Py."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"# Create list [1, ..., 5] \nprint ([ x + 1 for x in range(5) ])\n\n# Create two lists containg 5 integer variables\nX = [ Int('x%s' % i) for i in range(5) ]\nY = [ Int('y%s' % i) for i in range(5) ]\nprint (X)\n\n# Create a list containing X[i]+Y[i]\nX_plus_Y = [ X[i] + Y[i] for i in range(5) ]\nprint (X_plus_Y)\n\n# Create a list containing X[i] > Y[i]\nX_gt_Y = [ X[i] > Y[i] for i in range(5) ]\nprint (X_gt_Y)\n\nprint (And(X_gt_Y))\n\n# Create a 3x3 \"matrix\" (list of lists) of integer variables\nX = [ [ Int(\"x_%s_%s\" % (i+1, j+1)) for j in range(3) ] \n      for i in range(3) ]\npp(X)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"In the example above, the expression ",(0,a.kt)("inlineCode",{parentName:"p"},'"x%s" % i')," returns a string where ",(0,a.kt)("inlineCode",{parentName:"p"},"%s")," is replaced with the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"i"),"."),(0,a.kt)("p",null,"The command ",(0,a.kt)("inlineCode",{parentName:"p"},"pp")," is similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"print"),", but it uses Z3Py formatter for lists and tuples instead of Python's formatter."),(0,a.kt)("p",null,"Z3Py also provides functions for creating vectors of Boolean, Integer and Real variables. These functions\nare implemented using list comprehensions. "),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"X = IntVector('x', 5)\nY = RealVector('y', 5)\nP = BoolVector('p', 5)\nprint (X)\nprint (Y)\nprint (P)\nprint ([ y**2 for y in Y ])\nprint (Sum([ y**2 for y in Y ]))",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"kinematic-equations"},"Kinematic Equations"),(0,a.kt)("p",null,"In high school, students learn the kinematic equations.\nThese equations describe the mathematical relationship between ",(0,a.kt)("strong",{parentName:"p"},"displacement")," (",(0,a.kt)("inlineCode",{parentName:"p"},"d"),"),\n",(0,a.kt)("strong",{parentName:"p"},"time")," (",(0,a.kt)("inlineCode",{parentName:"p"},"t"),"), ",(0,a.kt)("strong",{parentName:"p"},"acceleration")," (",(0,a.kt)("inlineCode",{parentName:"p"},"a"),"), ",(0,a.kt)("strong",{parentName:"p"},"initial velocity")," (",(0,a.kt)("inlineCode",{parentName:"p"},"v_i"),") and ",(0,a.kt)("strong",{parentName:"p"},"final velocity")," (",(0,a.kt)("inlineCode",{parentName:"p"},"v_f"),").\nIn Z3Py notation, we can write these equations as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"   d == v_i * t + (a*t**2)/2,\n   v_f == v_i + a*t\n")),(0,a.kt)("h3",{id:"problem-1"},"Problem 1"),(0,a.kt)("p",null,"Ima Hurryin is approaching a stoplight moving with a velocity of ",(0,a.kt)("inlineCode",{parentName:"p"},"30.0")," m/s.\nThe light turns yellow, and Ima applies the brakes and skids to a stop.\nIf Ima's acceleration is ",(0,a.kt)("inlineCode",{parentName:"p"},"-8.00")," m/s",(0,a.kt)("sup",null,"2"),", then determine the displacement of the\ncar during the skidding process. "),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'d, a, t, v_i, v_f = Reals(\'d a t v__i v__f\')\n\nequations = [\n   d == v_i * t + (a*t**2)/2,\n   v_f == v_i + a*t,\n]\nprint ("Kinematic equations:")\nprint (equations)\n\n# Given v_i, v_f and a, find d\nproblem = [\n    v_i == 30,\n    v_f == 0,\n    a   == -8\n]\nprint ("Problem:")\nprint (problem) \n\nprint ("Solution:")\nsolve(equations + problem)',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h3",{id:"problem-2"},"Problem 2"),(0,a.kt)("p",null,"Ben Rushin is waiting at a stoplight. When it finally turns green, Ben accelerated from rest at a rate of\na ",(0,a.kt)("inlineCode",{parentName:"p"},"6.00")," m/s",(0,a.kt)("sup",null,"2")," for a time of ",(0,a.kt)("inlineCode",{parentName:"p"},"4.10")," seconds. Determine the displacement of Ben's car during this time period."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"d, a, t, v_i, v_f = Reals('d a t v__i v__f')\n\nequations = [\n   d == v_i * t + (a*t**2)/2,\n   v_f == v_i + a*t,\n]\n\n# Given v_i, t and a, find d\nproblem = [\n    v_i == 0,\n    t   == 4.10,\n    a   == 6\n]\n\nsolve(equations + problem)\n\n# Display rationals in decimal notation\nset_option(rational_to_decimal=True)\n\nsolve(equations + problem)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"bit-tricks"},"Bit Tricks"),(0,a.kt)("p",null,"Some low level ",(0,a.kt)("a",{parentName:"p",href:"http://graphics.stanford.edu/~seander/bithacks.html"},"hacks")," are very popular with C programmers.\nWe use some of these hacks in the Z3 implementation."),(0,a.kt)("h3",{id:"power-of-two"},"Power of two"),(0,a.kt)("p",null,"This hack is frequently used in C programs (Z3 included) to test whether a machine integer is a power of two.\nWe can use Z3 to prove it really works. The claim is that ",(0,a.kt)("inlineCode",{parentName:"p"},"x != 0 && !(x & (x - 1))")," is true if and only if ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),"\nis a power of two."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x      = BitVec('x', 32)\npowers = [ 2**i for i in range(32) ]\nfast   = And(x != 0, x & (x - 1) == 0)\nslow   = Or([ x == p for p in powers ])\nprint (fast)\nprove(fast == slow)\n\nprint (\"trying to prove buggy version...\")\nfast   = x & (x - 1) == 0\nprove(fast == slow)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h3",{id:"opposite-signs"},"Opposite signs"),(0,a.kt)("p",null,"The following simple hack can be used to test whether two machine integers have opposite signs."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"x      = BitVec('x', 32)\ny      = BitVec('y', 32)\n\n# Claim: (x ^ y) < 0 iff x and y have opposite signs\ntrick  = (x ^ y) < 0\n\n# Naive way to check if x and y have opposite signs\nopposite = Or(And(x < 0, y >= 0),\n              And(x >= 0, y < 0))\n\nprove(trick == opposite)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"puzzles"},"Puzzles"),(0,a.kt)("h3",{id:"dog-cat-and-mouse"},"Dog, Cat and Mouse"),(0,a.kt)("p",null,"Consider the following puzzle. Spend exactly 100 dollars and buy exactly 100 animals.\nDogs cost 15 dollars, cats cost 1 dollar, and mice cost 25 cents each.\nYou have to buy at least one of each.\nHow many of each should you buy?"),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"# Create 3 integer variables\ndog, cat, mouse = Ints('dog cat mouse')\nsolve(dog >= 1,   # at least one dog\n      cat >= 1,   # at least one cat\n      mouse >= 1, # at least one mouse\n      # we want to buy 100 animals\n      dog + cat + mouse == 100,  \n      # We have 100 dollars (10000 cents):\n      #   dogs cost 15 dollars (1500 cents), \n      #   cats cost 1 dollar (100 cents), and \n      #   mice cost 25 cents \n      1500 * dog + 100 * cat + 25 * mouse == 10000)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h3",{id:"sudoku"},"Sudoku"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"http://www.dailysudoku.com/sudoku/"},"Sudoku")," is a very popular puzzle.\nThe goal is to insert the numbers in the boxes to satisfy only one condition: each row, column and\n",(0,a.kt)("inlineCode",{parentName:"p"},"3x3")," box must contain the digits ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," through ",(0,a.kt)("inlineCode",{parentName:"p"},"9")," exactly once. "),(0,a.kt)("p",null,"The following example encodes the suduko problem in Z3. Different sukudo instances can be solved\nby modifying the matrix ",(0,a.kt)("inlineCode",{parentName:"p"},"instance"),". This example makes heavy use of\n",(0,a.kt)("a",{parentName:"p",href:"http://docs.python.org/tutorial/datastructures.html#list-comprehensions"},"list comprehensions"),"\navailable in the Python programming language."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'# 9x9 matrix of integer variables\nX = [ [ Int("x_%s_%s" % (i+1, j+1)) for j in range(9) ] \n      for i in range(9) ]\n\n# each cell contains a value in {1, ..., 9}\ncells_c  = [ And(1 <= X[i][j], X[i][j] <= 9) \n             for i in range(9) for j in range(9) ]\n\n# each row contains a digit at most once\nrows_c   = [ Distinct(X[i]) for i in range(9) ]\n\n# each column contains a digit at most once\ncols_c   = [ Distinct([ X[i][j] for i in range(9) ]) \n             for j in range(9) ]\n\n# each 3x3 square contains a digit at most once\nsq_c     = [ Distinct([ X[3*i0 + i][3*j0 + j] \n                        for i in range(3) for j in range(3) ]) \n             for i0 in range(3) for j0 in range(3) ]\n\nsudoku_c = cells_c + rows_c + cols_c + sq_c\n\n# sudoku instance, we use \'0\' for empty cells\ninstance = ((0,0,0,0,9,4,0,3,0),\n            (0,0,0,5,1,0,0,0,7),\n            (0,8,9,0,0,0,0,4,0),\n            (0,0,0,0,0,0,2,0,8),\n            (0,6,0,2,0,1,0,5,0),\n            (1,0,2,0,0,0,0,0,0),\n            (0,7,0,0,0,0,5,2,0),\n            (9,0,0,0,6,5,0,0,0),\n            (0,4,0,9,7,0,0,0,0))\n\ninstance_c = [ If(instance[i][j] == 0, \n                  True, \n                  X[i][j] == instance[i][j]) \n               for i in range(9) for j in range(9) ]\n\ns = Solver()\ns.add(sudoku_c + instance_c)\nif s.check() == sat:\n    m = s.model()\n    r = [ [ m.evaluate(X[i][j]) for j in range(9) ] \n          for i in range(9) ]\n    print_matrix(r)\nelse:\n    print ("failed to solve")',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h3",{id:"eight-queens"},"Eight Queens"),(0,a.kt)("p",null,"The eight queens puzzle is the problem of placing eight chess queens on an 8x8 chessboard so that no two queens attack each other.\nThus, a solution requires that no two queens share the same row, column, or diagonal."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"# We know each queen must be in a different row.\n# So, we represent each queen by a single integer: the column position\nQ = [ Int('Q_%i' % (i + 1)) for i in range(8) ]\n\n# Each queen is in a column {1, ... 8 }\nval_c = [ And(1 <= Q[i], Q[i] <= 8) for i in range(8) ]\n\n# At most one queen per column\ncol_c = [ Distinct(Q) ]\n\n# Diagonal constraint\ndiag_c = [ If(i == j, \n              True, \n              And(Q[i] - Q[j] != i - j, Q[i] - Q[j] != j - i)) \n           for i in range(8) for j in range(i) ]\n\nsolve(val_c + col_c + diag_c)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("h2",{id:"application-install-problem"},"Application: Install Problem"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"install problem")," consists of determining whether a new set of packages can be installed in a system.\nThis application is based on the article\n",(0,a.kt)("a",{parentName:"p",href:"http://cseweb.ucsd.edu/~rjhala/papers/opium.pdf"},"OPIUM: Optimal Package Install/Uninstall Manager"),".\nMany packages depend on other packages to provide some functionality.\nEach distribution contains a meta-data file that\nexplicates the requirements of each package of the distribution\nThe meta-data contains details like the name, version, etc. More importantly, it contains\n",(0,a.kt)("strong",{parentName:"p"},"depends")," and ",(0,a.kt)("strong",{parentName:"p"},"conflicts"),"\nclauses that stipulate which other packages should be on the\nsystem. The depends clauses stipulate which other packages must be present.\nThe conflicts clauses stipulate which other packages must not be present."),(0,a.kt)("p",null,"The install problem can be easily solved using Z3. The idea is to define a Boolean variable for each\npackage. This variable is true if the package must be in the system. If package ",(0,a.kt)("inlineCode",{parentName:"p"},"a")," depends on\npackages ",(0,a.kt)("inlineCode",{parentName:"p"},"b"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"c")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"z"),", we write:"),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"DependsOn(a, [b, c, z])",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"DependsOn")," is a simple Python function that creates Z3 constraints that capture the\ndepends clause semantics."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"def DependsOn(pack, deps):\n   return And([ Implies(pack, dep) for dep in deps ])",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"Thus, ",(0,a.kt)("inlineCode",{parentName:"p"},"Depends(a, [b, c, z])")," generates the constraint"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"And(Implies(a, b), Implies(a, c), Implies(a, z))\n")),(0,a.kt)("p",null,"That is, if users install package ",(0,a.kt)("inlineCode",{parentName:"p"},"a"),", they must also install packages\n",(0,a.kt)("inlineCode",{parentName:"p"},"b"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"c")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"z"),". "),(0,a.kt)("p",null,"If package ",(0,a.kt)("inlineCode",{parentName:"p"},"d")," conflicts with package ",(0,a.kt)("inlineCode",{parentName:"p"},"e"),", we write ",(0,a.kt)("inlineCode",{parentName:"p"},"Conflict(d, e)"),".\n",(0,a.kt)("inlineCode",{parentName:"p"},"Conflict")," is also a simple Python function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"def Conflict(p1, p2):\n    return Or(Not(p1), Not(p2))\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Conflict(d, e)")," generates the constraint ",(0,a.kt)("inlineCode",{parentName:"p"},"Or(Not(d), Not(e))"),".\nWith these two functions, we can easily encode the example in the\n",(0,a.kt)("a",{parentName:"p",href:"http://cseweb.ucsd.edu/~rjhala/papers/opium.pdf"},"Opium article")," (Section 2) in Z3Py as:"),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"def DependsOn(pack, deps):\n    return And([ Implies(pack, dep) for dep in deps ])\n\ndef Conflict(p1, p2):\n    return Or(Not(p1), Not(p2))\n\na, b, c, d, e, f, g, z = Bools('a b c d e f g z')\n\nsolve(DependsOn(a, [b, c, z]),\n      DependsOn(b, [d]),\n      DependsOn(c, [Or(d, e), Or(f, g)]),\n      Conflict(d, e),\n      a, z)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"Note that the example contains the constraint"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"DependsOn(c, [Or(d, e), Or(f, g)]),\n")),(0,a.kt)("p",null,"The meaning is: to install ",(0,a.kt)("inlineCode",{parentName:"p"},"c"),", we must install ",(0,a.kt)("inlineCode",{parentName:"p"},"d")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"e"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"f")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"g")),(0,a.kt)("p",null,"Now, we refine the previous example. First, we modify ",(0,a.kt)("inlineCode",{parentName:"p"},"DependsOn")," to allow\nus to write ",(0,a.kt)("inlineCode",{parentName:"p"},"DependsOn(b, d)")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"DependsOn(b, [d])"),". We also\nwrite a function ",(0,a.kt)("inlineCode",{parentName:"p"},"install_check")," that returns a list of packages that must be installed\nin the system. The function ",(0,a.kt)("inlineCode",{parentName:"p"},"Conflict")," is also modified. It can now receive multiple\narguments."),(0,a.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'def DependsOn(pack, deps):\n    if is_expr(deps):\n        return Implies(pack, deps)\n    else:\n        return And([ Implies(pack, dep) for dep in deps ])\n\ndef Conflict(*packs):\n    return Or([ Not(pack) for pack in packs ])\n\na, b, c, d, e, f, g, z = Bools(\'a b c d e f g z\')\n\ndef install_check(*problem):\n    s = Solver()\n    s.add(*problem)\n    if s.check() == sat:\n        m = s.model()\n        r = []\n        for x in m:\n            if is_true(m[x]):\n                # x is a Z3 declaration\n                # x() returns the Z3 expression\n                # x.name() returns a string\n                r.append(x())\n        print (r)\n    else:\n        print ("invalid installation profile")\n\nprint ("Check 1")\ninstall_check(DependsOn(a, [b, c, z]),\n              DependsOn(b, d),\n              DependsOn(c, [Or(d, e), Or(f, g)]),\n              Conflict(d, e),\n              Conflict(d, g),\n              a, z)\n\nprint ("Check 2")\ninstall_check(DependsOn(a, [b, c, z]),\n              DependsOn(b, d),\n              DependsOn(c, [Or(d, e), Or(f, g)]),\n              Conflict(d, e),\n              Conflict(d, g),\n              a, z, g)',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}))}u.isMDXComponent=!0}}]);