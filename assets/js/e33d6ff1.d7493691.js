"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6932],{3197:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var o=t(3117),a=(t(7294),t(3905)),n=t(7634),i=t.n(n);const r={title:"Goals",sidebar_position:2},l=void 0,c={unversionedId:"strategies/goals",id:"strategies/goals",title:"Goals",description:'Z3 implements a methodology for orchestrating reasoning engines where "big" symbolic reasoning steps are represented as functions known as tactics, and tactics are composed using combinators known as tacticals. Tactics process sets of formulas called Goals.',source:"@site/docs-smtlib/03 - strategies/02 - goals.md",sourceDirName:"03 - strategies",slug:"/strategies/goals",permalink:"/z3guide/docs/strategies/goals",draft:!1,editUrl:"https://github.com/rlisahuang/z3guide/tree/main/website/docs-smtlib/03 - strategies/02 - goals.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Goals",sidebar_position:2},sidebar:"smtlibSidebar",previous:{title:"Introduction",permalink:"/z3guide/docs/strategies/intro"},next:{title:"Tactics",permalink:"/z3guide/docs/strategies/tactics"}},u={},d=[],p={toc:d};function m(e){let{components:s,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,t,{components:s,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'Z3 implements a methodology for orchestrating reasoning engines where "big" symbolic reasoning steps are represented as functions known as tactics, and tactics are composed using combinators known as tacticals. Tactics process sets of formulas called Goals.'),(0,a.kt)("p",null,"When a tactic is applied to some goal G, four different outcomes are possible. In SMT 2.0, the goal is the conjunction of all assertions. The tactic succeeds in showing G to be satisfiable (i.e., feasible); succeeds in showing G to be unsatisfiable (i.e., infeasible); produces a sequence of subgoals; or fails. When reducing a goal G to a sequence of subgoals G1, ..., Gn, we face the problem of model conversion. A model converter construct a model for G using a model for some subgoal Gi."),(0,a.kt)("p",null,"In the following example, we use the command apply to execute a tactic composed of two built-in tactics: simplify and solve-eqs. The tactic simplify apply transformations equivalent to the ones found in the command simplify. The tactic solver-eqs eliminate variables using Gaussian elimination. Actually, solve-eqs is not restricted only to linear arithmetic. It can also eliminate arbitrary variables. Then, combinator then applies simplify to the input goal and solve-eqs to each subgoal produced by simplify. In this example, only one subgoal is produced."),(0,a.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n\n(assert (> x 0.0))\n(assert (> y 0.0))\n(assert (= x (+ y 2.0)))\n\n(apply (then simplify solve-eqs))",result:{output:"(goals\n(goal\n  (not (<= y (- 2.0)))\n  (not (<= y 0.0))\n  :precision precise :depth 2)\n)\n",error:"",status:"z3-ran",hash:"e4c22d8d73d4e66cf8ca58f0ae7f747aec770c2c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"In the example above, variable x is eliminated, and is not present the resultant goal."),(0,a.kt)("p",null,"In Z3, we say a clause is any constraint of the form (or f_1 ... f_n). The tactic split-clause will select a clause (or f_1 ... f_n) in the input goal, and split it n subgoals. One for each subformula f_i."),(0,a.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n\n(assert (or (< x 0.0) (> x 0.0)))\n(assert (= x (+ y 1.0)))\n(assert (< y 0.0))\n\n(apply split-clause)",result:{output:"(goals\n(goal\n  (< x 0.0)\n  (= x (+ y 1.0))\n  (< y 0.0)\n  :precision precise :depth 1)\n(goal\n  (> x 0.0)\n  (= x (+ y 1.0))\n  (< y 0.0)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"3248ebfc582bf18cdbdd5336fc6b5ea7de378b2a"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}))}m.isMDXComponent=!0}}]);